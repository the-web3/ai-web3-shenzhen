// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

contract RebalanceRouter {
    address public dexAddress;  // TinyDEX 地址
    address public nftAddress;  // SimpleNFT 地址
    
    event RebalanceExecuted(address indexed user, uint256 tokenId, uint256 totalTrades);
    event RefundIssued(address indexed user, uint256 amount);
    
    constructor(address _dexAddress, address _nftAddress) {
        dexAddress = _dexAddress;
        nftAddress = _nftAddress;
    }
    
    // 核心：一键再平衡函数
    function executeOneClickRebalance(
        uint256 tokenId,
        address[] calldata tokensToBuy,
        uint256[] calldata amountsToBuy,
        address[] calldata tokensToSell,
        uint256[] calldata amountsToSell
    ) external payable {
        require(_validateNFTOwnership(tokenId), "Not NFT owner or invalid NFT");
        
        uint256 totalTrades = 0;
        uint256 totalDevNeeded = 0;
        
        // 计算买入所需的总DEV
        for(uint256 i = 0; i < amountsToBuy.length; i++) {
            if(amountsToBuy[i] > 0) {
                totalDevNeeded += amountsToBuy[i] / 10000;
            }
        }
        
        require(msg.value >= totalDevNeeded, "Insufficient DEV sent");
        
        // 执行卖出操作
        for(uint256 i = 0; i < tokensToSell.length; i++) {
            if(amountsToSell[i] > 0) {
                _executeSell(tokensToSell[i], amountsToSell[i]);  // 恢复tokenAddress参数
                totalTrades++;
            }
        }
        
        // 执行买入操作
        for(uint256 i = 0; i < tokensToBuy.length; i++) {
            if(amountsToBuy[i] > 0) {
                uint256 devCost = amountsToBuy[i] / 10000;
                _executeBuy(tokensToBuy[i], devCost);  // 恢复tokenAddress参数
                totalTrades++;
            }
        }
        
        // 退还多余的DEV
        if(msg.value > totalDevNeeded) {
            uint256 refundAmount = msg.value - totalDevNeeded;
            (bool success, ) = payable(msg.sender).call{value: refundAmount}("");
            require(success, "Refund failed");
            emit RefundIssued(msg.sender, refundAmount);
        }
        
        emit RebalanceExecuted(msg.sender, tokenId, totalTrades);
    }
    
    // 内部函数：验证NFT所有权
    function _validateNFTOwnership(uint256 tokenId) internal returns (bool) {
        (bool success, bytes memory data) = nftAddress.call(
            abi.encodeWithSignature("ownerOf(uint256)", tokenId)
        );
        
        if(!success) return false;
        address owner = abi.decode(data, (address));
        return owner == msg.sender;
    }
    
    // 内部函数：执行买入（恢复tokenAddress参数）
    function _executeBuy(address tokenAddress, uint256 devAmount) internal {
        (bool success, ) = dexAddress.call{value: devAmount}(
            abi.encodeWithSignature("buyToken(address)", tokenAddress)
        );
        require(success, "Buy transaction failed");
    }
    
    // 内部函数：执行卖出（恢复tokenAddress参数）
    function _executeSell(address tokenAddress, uint256 tokenAmount) internal {
        (bool success, ) = dexAddress.call(
            abi.encodeWithSignature("sellToken(address,uint256)", tokenAddress, tokenAmount)
        );
        require(success, "Sell transaction failed");
    }
    
    // 查询函数：计算所需DEV
    function calculateDevRequired(uint256[] calldata amountsToBuy) external pure returns (uint256) {
        uint256 total = 0;
        for(uint256 i = 0; i < amountsToBuy.length; i++) {
            if(amountsToBuy[i] > 0) {
                total += amountsToBuy[i] / 10000;
            }
        }
        return total + (total * 5 / 100); // 增加5%缓冲
    }
    
    receive() external payable {}
}